<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>關鍵點位戰情分析儀</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- html2canvas for Screenshot -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        /* Custom scrollbar for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f172a; 
        }
        ::-webkit-scrollbar-thumb {
            background: #334155; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #475569; 
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-200 font-sans overflow-hidden flex flex-col h-screen">

    <!-- Header -->
    <header class="p-4 border-b border-slate-800 bg-slate-900 flex justify-between items-center shadow-md z-10 shrink-0">
        <div class="flex items-center gap-2">
            <i data-lucide="activity" class="w-6 h-6 text-indigo-400"></i>
            <h1 class="text-xl font-bold text-white tracking-wide">關鍵點位戰情室</h1>
        </div>
        <div class="flex items-center gap-3 text-sm">
           <div class="flex items-center gap-2 bg-slate-800 px-3 py-1 rounded-full border border-slate-700">
             <span class="text-slate-400">過濾閾值:</span>
             <input 
                type="number" 
                id="threshold-input"
                value="1000" 
                class="w-16 bg-transparent text-center focus:outline-none text-indigo-300 font-mono"
             />
           </div>
           
           <button 
             id="export-btn"
             class="flex items-center gap-1 bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1 rounded-full transition-colors cursor-pointer shadow-lg shadow-indigo-900/20"
           >
             <i data-lucide="image-down" class="w-4 h-4"></i> 匯出圖片
           </button>

           <button 
             id="clear-btn"
             class="flex items-center gap-1 text-slate-400 hover:text-white transition-colors cursor-pointer ml-2"
           >
             <i data-lucide="refresh-ccw" class="w-4 h-4"></i> 清除
           </button>
        </div>
    </header>

    <main id="capture-area" class="flex-1 flex flex-col md:flex-row overflow-hidden relative bg-slate-950">
        
        <!-- Column 1: Input -->
        <div class="w-full md:w-1/3 flex flex-col border-r border-slate-800 min-h-[300px] relative">
            <div class="p-3 bg-slate-900 text-xs text-slate-400 font-semibold uppercase tracking-wider border-b border-slate-800 shrink-0">
                原始情報輸入
            </div>
            <textarea
                id="input-text"
                class="flex-1 w-full bg-slate-950 p-4 resize-none focus:outline-none focus:ring-1 focus:ring-indigo-900 text-slate-300 text-sm leading-relaxed font-mono"
                placeholder="請在此貼上包含點位的分析文字..."
            ></textarea>
            <!-- Hidden div for export rendering -->
            <div id="input-text-export-view" class="hidden absolute inset-0 top-[41px] z-20 bg-slate-950 p-4 text-slate-300 text-sm leading-relaxed font-mono whitespace-pre-wrap overflow-hidden pointer-events-none"></div>
        </div>

        <!-- Column 2: List Analysis -->
        <div class="w-full md:w-1/3 flex flex-col border-r border-slate-800 bg-slate-900/50 min-h-[300px] relative">
            <div class="p-3 bg-slate-900 text-xs text-slate-400 font-semibold uppercase tracking-wider border-b border-slate-800 flex justify-between shrink-0">
                <span>點位排序 (高 → 低)</span>
                <span id="point-count" class="text-indigo-400">0 筆數據</span>
            </div>
            
            <div id="points-list" class="flex-1 overflow-y-auto p-2 space-y-1">
                <!-- Content will be injected here via JS -->
            </div>
        </div>

        <!-- Column 3: Visualization -->
        <div class="w-full md:w-1/3 flex flex-col bg-slate-950 relative min-h-[300px]">
            <div class="p-3 bg-slate-900 text-xs text-slate-400 font-semibold uppercase tracking-wider border-b border-slate-800 shrink-0">
                戰場分佈圖
            </div>
            
            <div class="flex-1 relative p-6 overflow-y-auto flex justify-center" id="viz-container">
                <!-- Content will be injected here via JS -->
            </div>
        </div>

    </main>

    <script>
        // --- Configuration & State ---
        const STORAGE_KEY_TEXT = 'kpa_saved_text';
        const STORAGE_KEY_THRESHOLD = 'kpa_saved_threshold';

        const defaultText = `核心點位 (B2)
27707
趨勢 Bias0
本時段波動邊界
預估壓力 (High)
28634(+3.35%)
預估支撐 (Low)
26780(-3.35%)
大盤防守 (Market)
大盤壓力 (B10)
28140大盤支撐 (B12)
27260
預估結算區間：28,100 ～ 28,350 （偏多看待）`;

        const thresholdInput = document.getElementById('threshold-input');
        const inputText = document.getElementById('input-text');
        const clearBtn = document.getElementById('clear-btn');
        const exportBtn = document.getElementById('export-btn');
        const pointsListEl = document.getElementById('points-list');
        const pointCountEl = document.getElementById('point-count');
        const vizContainerEl = document.getElementById('viz-container');
        const inputTextExportView = document.getElementById('input-text-export-view');

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadState(); // Load saved data
            analyze();   // Initial analysis
        });

        inputText.addEventListener('input', () => {
            saveState();
            analyze();
        });

        thresholdInput.addEventListener('input', () => {
            saveState();
            analyze();
        });
        
        clearBtn.addEventListener('click', () => {
            inputText.value = '';
            saveState();
            analyze();
        });

        exportBtn.addEventListener('click', exportImage);

        // --- Persistence Logic (Local Storage) ---
        function saveState() {
            localStorage.setItem(STORAGE_KEY_TEXT, inputText.value);
            localStorage.setItem(STORAGE_KEY_THRESHOLD, thresholdInput.value);
        }

        function loadState() {
            const savedText = localStorage.getItem(STORAGE_KEY_TEXT);
            const savedThreshold = localStorage.getItem(STORAGE_KEY_THRESHOLD);

            if (savedText !== null) {
                inputText.value = savedText;
            } else {
                inputText.value = defaultText;
            }

            if (savedThreshold !== null) {
                thresholdInput.value = savedThreshold;
            }
        }

        // --- Export Logic ---
        function exportImage() {
            const element = document.getElementById('capture-area');
            const originalBtnText = exportBtn.innerHTML;
            
            // 1. Prepare for capture: populate hidden div with textarea content and show it
            inputTextExportView.textContent = inputText.value;
            inputTextExportView.classList.remove('hidden');
            inputText.classList.add('opacity-0');

            // Show loading state on button
            exportBtn.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> 處理中...`;
            lucide.createIcons();

            setTimeout(() => {
                html2canvas(element, {
                    backgroundColor: '#020617', // slate-950 for dark mode
                    scale: 2 // High resolution
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `戰情分析_${new Date().toISOString().slice(0,10)}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    // Restore UI
                    exportBtn.innerHTML = originalBtnText;
                    lucide.createIcons();
                    inputTextExportView.classList.add('hidden');
                    inputText.classList.remove('opacity-0');

                }).catch(err => {
                    console.error("Export failed:", err);
                    alert("匯出失敗，請重試");
                    exportBtn.innerHTML = originalBtnText;
                    lucide.createIcons();
                    inputTextExportView.classList.add('hidden');
                    inputText.classList.remove('opacity-0');
                });
            }, 100);
        }

        // --- Core Logic ---
        function analyze() {
            const text = inputText.value;
            const threshold = Number(thresholdInput.value) || 1000;

            if (!text.trim()) {
                renderEmptyState();
                return;
            }

            // 1. Pre-process
            let processedText = text
                .replace(/（/g, '(')
                .replace(/）/g, ')')
                .replace(/％/g, '%')
                .replace(/：/g, ':')
                .replace(/～/g, '~');

            // 2. Remove percentage blocks
            processedText = processedText.replace(/\([^)]*%\)/g, ' '); 
            processedText = processedText.replace(/[+\-]?\d+(\.\d+)?\s*%/g, ' ');

            const lines = processedText.split('\n');
            let extractedPoints = [];

            lines.forEach((line, index) => {
                const cleanLine = line.trim();
                const regex = /[\d,]+\.?\d*/g;
                const matches = cleanLine.match(regex);

                if (matches) {
                    matches.forEach((matchStr) => {
                        const value = parseFloat(matchStr.replace(/,/g, ''));

                        if (!isNaN(value) && value > threshold) {
                            let label = '未定義';
                            const lineParts = cleanLine.split(matchStr);
                            const textBefore = lineParts[0].trim();
                            const textAfter = lineParts.slice(1).join(matchStr).trim();

                            // Label Priority Logic
                            if (textBefore && textBefore.length > 1) {
                                label = cleanLabel(textBefore);
                            } else if (index > 0) {
                                const prevLine = lines[index-1].trim();
                                if (prevLine && isNaN(parseFloat(prevLine.replace(/,/g,'')))) {
                                    label = cleanLabel(prevLine);
                                }
                            }
                            
                            if (label === '未定義' && textAfter) {
                                if (textAfter.startsWith('(') || textAfter.includes('壓力') || textAfter.includes('支撐')) {
                                    label = cleanLabel(textAfter);
                                }
                            }

                            extractedPoints.push({
                                id: `${index}-${value}`,
                                value: value,
                                originalLine: line.trim(),
                                label: label,
                                type: determineType(label)
                            });
                        }
                    });
                }
            });

            // Deduplicate: Keep FIRST occurrence of value only
            const uniquePoints = extractedPoints.filter((point, index, self) =>
                index === self.findIndex((t) => t.value === point.value)
            );

            // --- FILTER: Proximity (0.5%) & Outlier (10%) based on Core Point ---
            const corePoint = uniquePoints.find(p => p.type === 'core');
            let finalPoints = uniquePoints;

            if (corePoint) {
                const proximityBuffer = corePoint.value * 0.005; // 0.5%
                const upperProximity = corePoint.value + proximityBuffer;
                const lowerProximity = corePoint.value - proximityBuffer;

                const outlierThreshold = corePoint.value * 1.10; // 10%

                finalPoints = uniquePoints.filter(p => {
                    // Always keep the core point itself
                    if (p === corePoint) return true;
                    
                    // Filter 1: Remove points within 0.5% proximity
                    if (p.value >= lowerProximity && p.value <= upperProximity) {
                        return false;
                    }

                    // Filter 2: Remove points > 10% of Core (Outliers)
                    if (p.value > outlierThreshold) {
                        return false;
                    }

                    return true;
                });
            }

            // Sort Descending (after filtering)
            finalPoints.sort((a, b) => b.value - a.value);

            render(finalPoints);
        }

        // --- Helpers ---
        function cleanLabel(text) {
            return text.replace(/[\d,]/g, '').replace(/[()]/g, '').trim();
        }

        function determineType(label) {
            const l = label.toLowerCase();
            // Core Logic
            if (l.includes('核心') || l.includes('bias') || l.includes('中軸') || l.includes('current')) return 'core';
            // Resistance
            if (l.includes('壓力') || l.includes('high') || l.includes('高') || l.includes('上限')) return 'resistance';
            // Support
            if (l.includes('支撐') || l.includes('low') || l.includes('低') || l.includes('防守') || l.includes('下限')) return 'support';
            
            return 'neutral';
        }

        function getColorClasses(type) {
            switch (type) {
                case 'resistance': return 'text-red-400 border-red-900/50 bg-red-900/10';
                case 'support': return 'text-green-400 border-green-900/50 bg-green-900/10';
                case 'core': return 'text-amber-400 border-amber-500/50 bg-amber-900/20';
                default: return 'text-indigo-300 border-indigo-900/30 bg-indigo-900/10';
            }
        }

        function getBadgeColor(type) {
            switch (type) {
                case 'resistance': return 'bg-red-500';
                case 'support': return 'bg-green-500';
                case 'core': return 'bg-amber-500';
                default: return 'bg-indigo-500';
            }
        }

        function getIconName(type) {
             switch (type) {
                case 'resistance': return 'arrow-down';
                case 'support': return 'arrow-up';
                case 'core': return 'crosshair';
                default: return 'hash';
            }
        }

        // --- Rendering ---
        function renderEmptyState() {
            pointCountEl.innerText = "0 筆數據";
            pointsListEl.innerHTML = `
                <div class="h-full flex flex-col items-center justify-center text-slate-600">
                    <i data-lucide="search" class="w-12 h-12 mb-2 opacity-20"></i>
                    <p>等待數據分析...</p>
                </div>`;
            vizContainerEl.innerHTML = `
                <div class="flex items-center justify-center h-full text-slate-600 text-sm">
                  需至少兩個點位以建立模型
                </div>`;
            lucide.createIcons();
        }

        function render(points) {
            pointCountEl.innerText = `${points.length} 筆數據`;

            if (points.length === 0) {
                renderEmptyState();
                return;
            }

            // 1. Render List
            let listHtml = '';
            points.forEach(point => {
                const colors = getColorClasses(point.type);
                const icon = getIconName(point.type);
                const iconColor = point.type === 'resistance' ? 'text-red-400' : 
                                  point.type === 'support' ? 'text-green-400' : 
                                  point.type === 'core' ? 'text-amber-400' : 'text-indigo-400';
                
                listHtml += `
                <div class="relative group flex items-center justify-between p-2 rounded-lg border transition-all hover:scale-[1.01] hover:shadow-lg ${colors}">
                  <div class="flex flex-col max-w-[70%]">
                    <span class="text-[10px] opacity-70 mb-0.5 flex items-center gap-1 font-medium truncate">
                      <i data-lucide="${icon}" class="w-3 h-3 ${iconColor}"></i>
                      ${point.label === '未定義' ? '未知屬性' : point.label}
                    </span>
                    <span class="text-lg font-mono font-bold tracking-tight">
                      ${point.value.toLocaleString()}
                    </span>
                  </div>
                  <div class="text-[9px] text-right opacity-30 max-w-[80px] truncate hidden md:block">
                     ${point.originalLine}
                  </div>
                </div>`;
            });
            pointsListEl.innerHTML = listHtml;

            // 2. Render Viz
            if (points.length <= 1) {
                vizContainerEl.innerHTML = `
                <div class="flex items-center justify-center h-full text-slate-600 text-sm">
                  需至少兩個點位以建立模型
                </div>`;
            } else {
                const maxVal = Math.max(...points.map(p => p.value));
                const minVal = Math.min(...points.map(p => p.value));
                const range = maxVal - minVal || 1;

                let vizHtml = `<div class="relative w-full max-w-xs h-full min-h-[500px]">`;
                
                // Axis Line
                vizHtml += `<div class="absolute left-8 top-4 bottom-4 w-0.5 bg-slate-800 rounded-full"></div>`;

                points.forEach((point, idx) => {
                    const topPos = 100 - (((point.value - minVal) / range) * 100);
                    const isTight = idx > 0 && (points[idx-1].value - point.value) < (range * 0.08);
                    
                    const colors = getColorClasses(point.type);
                    const badgeBg = getBadgeColor(point.type);
                    
                    const markerColor = point.type === 'resistance' ? 'bg-red-500/50' : 
                                        point.type === 'support' ? 'bg-green-500/50' : 
                                        point.type === 'core' ? 'bg-amber-500/80 h-[3px]' : 'bg-indigo-500/50';

                    vizHtml += `
                     <div 
                       class="absolute left-0 w-full flex items-center group transition-all duration-500 ease-out"
                       style="top: ${topPos}%; transform: translateY(-50%); z-index: ${isTight ? 10 : 0}"
                     >
                       <div class="w-16 h-[2px] ${markerColor} mr-4 transition-all group-hover:w-20"></div>
                       
                       <div class="flex-1 flex items-center gap-3 p-2 rounded border backdrop-blur-md ${isTight ? 'ml-4' : ''} ${colors} shadow-xl cursor-default hover:brightness-110">
                          <div class="w-2 h-2 rounded-full shrink-0 ${badgeBg} ${point.type === 'core' ? 'animate-ping' : ''}"></div>
                          ${point.type === 'core' ? `<div class="absolute left-2 w-2 h-2 rounded-full shrink-0 ${badgeBg}"></div>` : ''}
                          
                          <div class="overflow-hidden">
                            <div class="font-mono font-bold text-lg leading-none">${point.value.toLocaleString()}</div>
                            <div class="text-[10px] uppercase tracking-wide opacity-80 truncate max-w-[120px]">
                                ${point.label !== '未定義' ? point.label : 'Point'}
                            </div>
                          </div>
                       </div>
                     </div>`;
                });

                vizHtml += `</div>`;
                vizContainerEl.innerHTML = vizHtml;
            }

            // Re-initialize icons for new elements
            lucide.createIcons();
        }
    </script>
</body>
</html>